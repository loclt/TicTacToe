"""The program demonstrates the popular game which are tic tac toe and scalable ability of Game.There are 2 main display in this game:    - MessageBox to ask the SIZE of game    - Main playing game screen.There are 2 cases of the game: Win and draw. The winner who possess 5 similar symbols a row vertically or horizontally.It allows to adjust the SIZE of board, symbol of players."""from tkinter import *from tkinter import simpledialogimport itertoolsfrom functools import partialimport tkinter.messagebox as messageBox"""Global variables.SIZE,BOARD,Symbols of each Player"""PLAYER01 = "X" # Symbol of Player01PLAYER02 = "O" # Symbol of Player02class TicTacToe:    def __init__(self):        self.__mainGame = Tk()        self.__mainGame.title("TIC TAC TOE GAME")        self.__mainGame.option_add("*Font", "Verdana 15")        self.__players = itertools.cycle([PLAYER01, PLAYER02]) # Create cycle function for players' turn        self.__player = next(self.__players)        self.__winnerPattern = [] # Create list of winning pattern        self.initialize_game() # Create initial variables for game        self.__mainGame.mainloop()    def initialize_game(self):        """        Using to ask to create the SIZE of game when play the game and restart the game.        :return:        """        SIZE = simpledialog.askinteger("Input", "What is the Size of Game?",parent=self.__mainGame,minvalue=0, maxvalue=100)        if SIZE >= 5:            self.winner_pattern(SIZE)  # Call winner_pattern function to create the winning pattern            self.startGame(SIZE)  # Start the game        else:            answer = messageBox.askyesno("Error", "Please create the Board's size to be greater than 5!\n"                                                  "Do you want to play again?")            if answer == False:  # If answer is No, it will quit game.                self.quitGame()  # Quit game            else:                self.initialize_game()  # If answer is Yes, it will start game again.    def cb_handler(self, position, button, SIZE):        """        When player click any button, it will check the existence of buttons which belong to each player.        If a player occupied a button, another player couldn't pick this button and must pick another.        It will simultaneously check the dict Button's position of each player with the winning patter.        :param position:        :param button:        :return:        """        if position not in self.__X_O_dict[PLAYER01] and \                position not in self.__X_O_dict[PLAYER02]:            self.__buttons[position].set(self.__player)            self.__X_O_dict[self.__player].append(position) #Append postions for each player after player click to button            button.configure(text=self.__player) # Configure text for button after click            if self.check_has_won(self.__X_O_dict[self.__player],SIZE) == True: # Check winner base on the winning pattern                result = messageBox.askyesno("Game Over", "Player {} has won\n".format(self.__player) + "Do you want to play again?")                if result == False: # If answer is No, it will quit game.                    self.quitGame() # Quit game                else:                    self.initialize_game() #If answer is Yes, it will start game again.            if self.check_has_won(self.__X_O_dict[self.__player],SIZE) == False:                result = messageBox.askyesno("Game Over", "DRAW GAME\nDo you want to play again?")                if result == False: # If answer is No, it will quit game.                    self.quitGame() # Quit game                else:                    self.initialize_game()  # If answer is Yes, it will start game again.            self.__player = next(self.__players) # Change turn to next player        else: # If player click button which is clicked by another            messageBox.showwarning("Warning","Occupied.\nPlease pick another")    def winner_pattern(self,SIZE):        """        Using to generate and calculate winning pattern automatically when we change the SIZE of board.        The winning pattern is 5 consecutive symbols.        :return: self.__winnerPattern list.        """        rowPattern = [] # Create list winning pattern for row line        colPattern = [] # Create list winning pattern for column line        cross_LR_Pattern = [] # Create list winning pattern for cross line        cross_RL_Pattern = [] # Create list winning pattern for cross line        dictRowPosition = {} # Create dict for position regarding to Row        dictColPosition = {} # Create dict for position regarding to Column        # Generating positions basing on table and map them to row's dict and column's dict        for position in range(SIZE * SIZE):            row = position // SIZE # Calculate row            column = position % SIZE # Calculate column            dictColPosition.update({position: column}) # Update the postions belong to column to dictColPosition            dictRowPosition.update({position: row}) # Update the postions belong to row to dictColPosition        # Generating winning pattern for the horizontal direction        for keyC, valueC in dictColPosition.items():            if 1 < valueC < SIZE - 2 and keyC + 2 < SIZE * SIZE:                colPattern.append([keyC - 2, keyC - 1, keyC, keyC + 1, keyC + 2])            else:                None        # Generating winning pattern for the vertical direction        for i in range(SIZE):            for keyR, valueR in dictRowPosition.items():                lastPosition = keyR + (SIZE * 4)                if (valueR == i) and lastPosition < SIZE * SIZE:                    rowPattern.append([keyR, keyR + SIZE, keyR + SIZE * 2, keyR + SIZE * 3, keyR + SIZE * 4])            else:                None        # Generating winning pattern for crossline from Left to Right        for keyC, valueC in dictColPosition.items():            lastPosition = keyC + ((SIZE + 1) * 4)            if valueC < SIZE - 4 and lastPosition < SIZE * SIZE:                cross_LR_Pattern.append([keyC, keyC + (SIZE + 1), keyC + ((SIZE + 1) * 2), keyC + ((SIZE + 1) * 3),                                         keyC + ((SIZE + 1) * 4)])            else:                None        #Generating winning pattern for crossline from Right to Left        for keyC, valueC in dictColPosition.items():            lastPosition = keyC + ((SIZE - 1) * 4)            if 3 < valueC < SIZE and lastPosition < SIZE * SIZE:                cross_RL_Pattern.append([keyC, keyC + (SIZE - 1), keyC + ((SIZE - 1) * 2), keyC + ((SIZE - 1) * 3),                                         keyC + ((SIZE - 1) * 4)])            else:                None        #Append these winning patterns above to WinnerPattern list.        self.__winnerPattern = colPattern + rowPattern + cross_LR_Pattern + cross_RL_Pattern    def check_has_won(self, list_in, SIZE):        """        Check the result of game is Win or Draw.        It will return True if there is anyone to win the game        It will return False if there is no one to win the game (DRAW)        :param list_in: List postion of each player which contain after click button.        :return:        """        for winner in self.__winnerPattern:            if set(winner).issubset(set(list_in)): # Compare the value in dict of Player to winning pattern                return True            if (len(self.__X_O_dict[PLAYER01]) + len(self.__X_O_dict[PLAYER02])) == (SIZE*SIZE):                # Check Draw when length of players' dict equal SIZE*SIZE                return False    def startGame(self,SIZE):        """        Function to start game and retry game after finish a game.        - Create a dict buttons        - Create a dict X_O which use for contain positions of each player        :return:        """        self.__buttons = {} # Generate dict buttons        self.__X_O_dict = {PLAYER01: [], PLAYER02: []} #Generate a dict in order to use for contain                                                        # positions of each player after click button        for position in range(SIZE*SIZE):            button = Button(self.__mainGame, text=" ")            row = position // SIZE  # Calculate row            column = position % SIZE  # Calculate column            self.__buttons[position] = StringVar()            self.__buttons[position].set(str(position))            button.grid(row=row, column=column) # Generate button on GUI base on row and column            button.configure(command=partial(self.cb_handler,position,button,SIZE)) # Use partial function to call cb_handler function                                                                                    # after each click for each seperated button    def quitGame(self):        self.__mainGame.destroy() # Close the boarddef main():    TicTacToe()main()